# -*- coding: utf-8 -*-
"""DAA2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h69IQZZOv2GgMtzB77lUVTn2MRLJhTrQ
"""

from google.colab import drive

drive.mount('/content/drive')

import pandas as pd
import numpy as np
import xgboost as xgb

from copy import copy
import datetime
import pickle
from geopy.geocoders import Nominatim

filename = "/content/drive/MyDrive/data/xgb_model.sav"
loaded_model = pickle.load(open(filename, 'rb'))

#Sample test locations
test_locations = {'L1': (12.9715987, 77.5945627),
                  'L2': (12.9579256, 77.7446238),
                  'L3': (12.9545177, 77.3507356),
                  'L4': (12.9140147, 77.6360978),
                  'L5': (12.9236181, 77.4989122)


             }

geolocator = Nominatim(user_agent="my_app")
addresses = []

for key in test_locations:
    location = geolocator.reverse(test_locations[key])
    addresses.append(location.address)

addresses

test_addresses={'L1':'St. Joseph Indian High School, Vittal Mallya Road, Sampangirama Nagar, Sampangiram Nagar Ward, East Zone, Bengaluru',
                'L2':'Manipal Hospitals, Whitefield Main Road, Vinayaka Layout, Hagadur, Mahadevapura Zone, Bengaluru',
                'L3':'Gangapa, Cholanayakanahalli, Bangalore South, Bangalore ',
                'L4':'115, 9th Main Road, Sector 5, HSR Layout Ward, Bommanahalli Zone, Bengaluru',
                'L5':'R. V. College of Engineering, Patanagere Main Road, Pattanagere, Hemmigepura, Rajarajeshwari Nagar Zone, Bengaluru'

}

def create_guess(points):

    guess = copy(points)
    np.random.shuffle(guess)
    guess.append(guess[0])
    return list(guess)

create_guess(list(test_locations.keys()))

def create_generation(points, population=100):

    generation = [create_guess(points) for _ in range(population)]
    return generation

test_generation = create_generation(list(test_locations.keys()), population=10)
print(test_generation)

def travel_time_between_points(point1_id, point2_id):


    model_data = { 'src_lat' : point1_id[0],

                  'src_long' : point1_id[1],
                  'des_lat' : point2_id[0],

                  'des_long' : point2_id[1],
                  'latitude_difference' : point2_id[0] - point1_id[0],
                  'longitude_difference' : point2_id[1] - point1_id[1],
                  'trip_distance' : 0.621371 * 6371 * (abs(2 * np.arctan2(np.sqrt(np.square(np.sin((abs(point2_id[0] - point1_id[0]) * np.pi / 180) / 2))),
                                  np.sqrt(1-(np.square(np.sin((abs(point2_id[0] - point1_id[0]) * np.pi / 180) / 2)))))) + \
                                     abs(2 * np.arctan2(np.sqrt(np.square(np.sin((abs(point2_id[1] - point1_id[1]) * np.pi / 180) / 2))),
                                  np.sqrt(1-(np.square(np.sin((abs(point2_id[1] - point1_id[1]) * np.pi / 180) / 2)))))))
                 }

    df = pd.DataFrame([model_data], columns=model_data.keys())

    pred = np.exp(loaded_model.predict(xgb.DMatrix(df))) - 1

    return pred[0]

coordinates = test_locations

def fitness_score(guess):

    score = 0
    for ix, point_id in enumerate(guess[:-1]):
        score += travel_time_between_points(coordinates[point_id], coordinates[guess[ix+1]])
    return score

def check_fitness(guesses):

    fitness_indicator = []
    for guess in guesses:
        fitness_indicator.append((guess, fitness_score(guess)))
    return fitness_indicator

print(check_fitness(test_generation))

def get_breeders_from_generation(guesses, take_best_N=10, take_random_N=5, verbose=False, mutation_rate=0.1):

    # First, get the top guesses from last time
    fit_scores = check_fitness(guesses)
    sorted_guesses = sorted(fit_scores, key=lambda x: x[1]) # sorts so lowest is first, which we want
    new_generation = [x[0] for x in sorted_guesses[:take_best_N]]
    best_guess = new_generation[0]

    if verbose:
        # If we want to see what the best current guess is!
        print(best_guess)

    # Second, get some random ones for genetic diversity
    for _ in range(take_random_N):
        ix = np.random.randint(len(guesses))
        new_generation.append(guesses[ix])



    np.random.shuffle(new_generation)
    return new_generation, best_guess

def make_child(parent1, parent2):


    list_of_ids_for_parent1 = list(np.random.choice(parent1, replace=False, size=len(parent1)//2))
    child = [-99 for _ in parent1]

    for ix in range(0, len(list_of_ids_for_parent1)):
        child[ix] = parent1[ix]
    for ix, gene in enumerate(child):
        if gene == -99:
            for gene2 in parent2:
                if gene2 not in child:
                    child[ix] = gene2
                    break
    child[-1] = child[0]
    return child

def make_children(old_generation, children_per_couple=1):

    mid_point = len(old_generation)//2
    next_generation = []

    for ix, parent in enumerate(old_generation[:mid_point]):
        for _ in range(children_per_couple):
            next_generation.append(make_child(parent, old_generation[-ix-1]))
    return next_generation

current_generation = create_generation(list(test_locations.keys()),population=500)
print_every_n_generations = 5

for i in range(100):
    if not i % print_every_n_generations:
        print("Generation %i: "%i, end='')
        print(len(current_generation))
        is_verbose = True
    else:
        is_verbose = False
    breeders, best_guess = get_breeders_from_generation(current_generation,
                                                        take_best_N=250, take_random_N=100,
                                                        verbose=is_verbose)
    current_generation = make_children(breeders, children_per_couple=3)

def evolve_to_solve(current_generation, max_generations, take_best_N, take_random_N,
                    mutation_rate, children_per_couple, print_every_n_generations, verbose=False):

    fitness_tracking = []
    for i in range(max_generations):
        if verbose and not i % print_every_n_generations and i > 0:
            print("Generation %i: "%i, end='')
            print(len(current_generation))
            print("Current Best Score: ", fitness_tracking[-1])
            is_verbose = True
        else:
            is_verbose = False
        breeders, best_guess = get_breeders_from_generation(current_generation,
                                                            take_best_N=take_best_N, take_random_N=take_random_N,
                                                            verbose=is_verbose, mutation_rate=mutation_rate)
        fitness_tracking.append(fitness_score(best_guess))
        current_generation = make_children(breeders, children_per_couple=children_per_couple)

    return fitness_tracking, best_guess

current_generation = create_generation(list(test_locations.keys()),population=500)
fitness_tracking, best_guess = evolve_to_solve(current_generation, 100, 150, 70, 0.5, 3, 5, verbose=True)

